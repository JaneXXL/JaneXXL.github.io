<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoJane</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-23T01:28:08.741Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/22/SVM/"/>
    <id>http://yoursite.com/2018/04/22/SVM/</id>
    <published>2018-04-22T08:45:45.492Z</published>
    <updated>2018-04-23T01:28:08.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p>SVM在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。</p><p>支持向量机方法是建立在<code>统计学习理论的VC 维理论</code>和<code>结构风险最小原理</code>基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力[14]（或称泛化能力）。</p><p>所谓VC维是对函数类的一种度量，VC维越高，一个问题就越复杂。SVM解决问题的时候，和样本的维数是无关的（甚至样本是上万维的都可以，这使得SVM很适合用来解决文本分类的问题，当然，有这样的能力也因为引入了核函数）。</p><p>真实风险应该由<code>经验风险</code>和<code>置信风险</code>。置信风险与<code>样本数量</code>和<code>VC维</code></p><p>泛化误差界的公式为：</p><p>$R(w)\leq R_{emp}(w)+\phi(n/h)$    R(w)就是真实风险，Remp(w)就是经验风险，Ф(n/h)就是置信风险</p><p>统计学习的目标从经验风险最小化变为了寻求经验风险与置信风险的和最小，即结构风险最小。</p><hr><h4 id="线性函数"><a href="#线性函数" class="headerlink" title="线性函数"></a>线性函数</h4><p>有一线性函数$g(x)=wx+b$</p><ul><li>x样本的向量表示</li><li>这个形式并不局限于二维的情况，在n维空间中仍然可以使用这个表达式</li></ul><p>每一个样本由一个向量（就是那些文本特征所组成的向量）和一个标记（标示出这个样本属于哪个类别）组成。如下：</p><p>$D_i=(x_i,y_i)$    xi就是文本向量（维数很高），yi就是分类标记。</p><p>在二元的线性分类中，这个表示分类的标记只有两个值，1和-1。我们就可以定义一个样本点到某个超平面的<code>间隔</code>：</p><p>$\delta_i=y_i(wx_i+b)$</p><p>归一化，<code>几何间隔</code>：</p><p>$\delta_i=\frac{1}{||w||}|g(x_i)|$    <code>没错，这不就是解析几何中点xi到直线g(x)=0的距离公式嘛！</code></p><p>当用归一化的w和b代替原值之后的间隔有一个专门的名称，叫做<code>几何间隔</code>-所表示的正是点到超平面的欧氏距离。</p><p><img src="C:\Users\xiaoJane\blog\public\images\3.png" alt="3"></p><p>几何间隔越大的解，它的误差上界越小。<code>最大化几何间隔与最小化||w||完全是一回事。</code></p><p>我们常用的方法并不是固定||w||的大小而寻求最大几何间隔，而是<code>固定间隔（例如固定为1），寻找最小的||w||</code>。</p><hr><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>$ min f(x)$     </p><p>$subject to ,C_i(x)\leq0,i=1,2,…,p$    </p><p>​        $C_j(x)=0,j=p+1,p+2,…,p+q$</p><p>要求f(x)在哪一点上取得最小值，但不是在整个空间里找，而是在约束条件所划定的一个有限的空间里找，这个有限的空间就是优化理论里所说的<code>可行域</code>。</p><p>$min\frac{1}{2}||w||^2 ,subject  to$   $y_i[(wx_i)+b]\geq1  (i=1,2,…,l)(l是样本数)$</p><p>这种规划问题称为<code>二次规划</code>,由于它的可行域是一个凸集，因此它是一个<code>凸二次规划</code>。</p><p>凸二次规划让人喜欢的地方就在于，它有解，且常常加限定成分，说它有<code>全局最优解</code></p><hr><h4 id="拉格朗日乘子"><a href="#拉格朗日乘子" class="headerlink" title="拉格朗日乘子"></a>拉格朗日乘子</h4><p>样本确定了w，用数学的语言描述，就是w可以表示为样本的某种组合：</p><p>$w=a_1x_1+a_2x_2+…+a_nx_n$</p><p>式子中的αi是一个一个的数（在严格的证明过程中，这些α被称为<code>拉格朗日乘子</code>），而xi是样本点，因而是向量，n就是总样本点的个数。</p><p>因此g(x)的表达式严格的形式应该是：</p><p>$g(x)=&lt;w,x&gt;+b$</p><p>$w=a_1y_1x_1+a_2y_2x_2+…+a_ny_nx_n$    简化：$w=\sum_{i=1}^{n}(a_iy_ix_i)$</p><p>原式为$g(x)=\sum_{i=1}^{n}a_iy_i&lt;x_i,x&gt;+b$</p><p><code>以这样的形式描述问题以后，我们的优化问题少了很大一部分不等式约束</code></p><h2 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h2><p>参考链接<a href="http://www.blogjava.net/zhenandaci/" target="_blank" rel="noopener">Jasper’s Java Jacal</a></p><p>提供的样本线性不可分，线性分类器求解程序会无限循环，如何将不可分数据变得线性可分？</p><p>二维空间的线性函数（直线）不能将两类正确分开。但曲线可以，问题是它不是一个线性函数。</p><p>$y=[ \begin{matrix}  y_1 \  y_2\  y_3\end{matrix}]=[ \begin{matrix}  1 \ x\ x^2\end{matrix}]$,$a=[ \begin{matrix}  a_1 \  a_2\  a_3\end{matrix}]=[ \begin{matrix}   c_0\ c_1\c_2\end{matrix}]$   对于$g(x)=c_0+c_1x+c_2x^2$</p><p>这样g(x)可以转化为$f(y)=&lt;a,y&gt;$ <code>在任意维度空间，这种形式的函数都是一个线性函数</code></p><p><code>原来在二维空间中一个线性不可分的问题，映射到四维空间后，变成了线性可分的！</code></p><p>例如：我们文本问题的原始空间是1000维（即每个被分类的文档被表示为一个1000维的向量），现在我们有一个2000维空间里的线性函数$f(x’)=<w',x'>+b,其中w’和x’都为2000维向量$ </w',x'></p><p><code>分类的过程是先把x变换为2000维的向量x’，然后求这个变换后的向量x’与向量w’的内积，再把这个内积的值和b相加，就得到了结果，看结果大于阈值还是小于阈值就得到了分类结果。</code></p><p>线性分类器：$f(x’)=\sum_{i=1}^{n} a_iy_i&lt;x_i’,x’&gt;+b$</p><p>用低维空间里的函数代替：$g(x)=\sum_{i=1}^{n}a_iy_iK(x_i,x)+b$</p><p>直接拿低维的输入向g(x)代入，<code>核函数K()的作用是接受两个低维空间里的向量，能够计算出经过某个变换后在高维空间里的向量内积值。</code></p><hr><h2 id="核函数的选择-松弛变量"><a href="#核函数的选择-松弛变量" class="headerlink" title="核函数的选择-松弛变量"></a>核函数的选择-松弛变量</h2><p><code>“硬间隔”分类法</code>：有噪声的情况会使得整个问题无解</p><p>$y_i[(wx_i)+b]\geq1$引入容错性，给1这个硬性的阈值加一个松弛变量$\xi_i\geq0$,$y_i[(wx_i)+b]\geq1-\xi_i$</p><p>原始的硬间隔分类对应的优化问题：</p><p>$min\frac{1}{2}||w||^2 ,subject  to$   $y_i[(wx_i)+b]\geq1  (i=1,2,…,l)(l是样本数)$</p><p>把损失加入到目标函数中，就需要一个惩罚因子C，优化问题变为：</p><p>$min\frac{1}{2}||w||^2+C\sum_{i=1}^{l}\xi_i ,subject  to$   $y_i[(wx_i)+b]\geq1-\xi_i  (i=1,2,…,l)(l是样本数),\xi_i\geq0$</p><p>但需要<code>注意</code>:</p><ul><li>并非所有的样本点都有一个松弛变量与其对应，实际上只有“离群点”才有。</li><li>松弛变量的值实际上标示出了对应的点到底离群有多远，值越大，点就越远。</li><li>惩罚因子C决定了你有多重视离群点带来的损失，当所有离群点的松弛变量的和一定时,你定的C越大，对目标函数的损失也越大，此时就暗示着你非常不愿意放弃这些离群点，最极端的情况是你把C定为无限大，这样只要稍有一个点离群，目标函数的值马上变成无限大，马上让问题变成无解，这就退化成了硬间隔问题。</li><li>C是一个你必须事先指定的值，指定这个值以后，解一下，得到一个分类器，然后用测试数据看看结果怎么样，如果不够好，换一个C的值。<code>优化问题在解的过程中，C一直是定值</code></li></ul><p>在原始的低维空间中，样本相当的不可分，无论你怎么找分类平面，总会有大量的离群点，此时用<code>核函数</code>向高维空间映射一下，虽然结果仍然是不可分的，但比原始空间里的要更加接近线性可分的状态（就是达到了近似线性可分的状态），此时再用<code>松弛变量</code>处理那些少数“冥顽不化”的离群点，就简单有效得多啦。</p><hr><h4 id="松弛变量-数据集偏斜"><a href="#松弛变量-数据集偏斜" class="headerlink" title="松弛变量-数据集偏斜"></a>松弛变量-数据集偏斜</h4><p>对付数据集偏斜问题的方法之一就是在<code>惩罚因子</code>上作文章，那就是给样本数量少的负类更大的惩罚因子，表示我们重视这部分样本</p><p>$C_+\sum_{i=1}^{p}\xi_i+C_-\sum_{j=p+1}^{p+q}\xi_j$$,\xi_i\geq0$</p><p>其中i=1…p都是正样本，j=p+1…p+q都是负样本</p><hr><h4 id="多类分类"><a href="#多类分类" class="headerlink" title="多类分类"></a>多类分类</h4><p>SVM是一种典型的两类分类器。</p><p>所谓<code>“一类对其余”</code>的方法，就是每次仍然解一个两类分类的问题，但会出现<code>分类重叠现象</code>和<code>不可分类现象</code></p><ul><li>把类别1的样本定为正样本，其余2，3，4，5的样本合起来定为负样本，这样得到一个两类分类器，它能够指出一篇文章是还是不是第1类的</li></ul><p><code>一对一</code>的方法，就是每次选一个类的样本作正类样本，而负类样本则变成只选一个类</p><ul><li>第一个只回答“是第1类还是第2类”</li></ul><p><code>DAG SVM</code>的方法是按下图组织分类器，但会存在错误向下累积的现象</p><p><img src="C:\Users\xiaoJane\blog\public\images\DAG_SVM.png" alt="DAG_SVM"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SVM&quot;&gt;&lt;a href=&quot;#SVM&quot; class=&quot;headerlink&quot; title=&quot;SVM&quot;&gt;&lt;/a&gt;SVM&lt;/h2&gt;&lt;p&gt;SVM在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。&lt;/p&gt;
&lt;p&gt;支持向
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建Blog</title>
    <link href="http://yoursite.com/2018/04/20/%E6%90%AD%E5%BB%BABlog/"/>
    <id>http://yoursite.com/2018/04/20/搭建Blog/</id>
    <published>2018-04-20T11:26:20.861Z</published>
    <updated>2018-04-23T01:26:14.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>可参考线上编辑器<a href="https://www.zybuluo.com/mdeditor?url=https%3A%2F%2Fwww.zybuluo.com%2Fstatic%2Feditor%2Fmd-help.markdown" target="_blank" rel="noopener">Cmd Markdown</a>和<a href="http://mahua.jser.me/" target="_blank" rel="noopener">MaHua</a></p><h2 id="Hexo-github-Theme搭建Blog"><a href="#Hexo-github-Theme搭建Blog" class="headerlink" title="Hexo+github+Theme搭建Blog"></a>Hexo+github+Theme搭建Blog</h2><hr><p>参考链接<a href="http://yangbingdong.com/2017/build-blog-hexo-base/" target="_blank" rel="noopener">基于Hexo+Github+Coding搭建个人博客</a>和<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">Hexo+Github一步步搭建博客</a></p><h3 id="1-配置Node-js和git"><a href="#1-配置Node-js和git" class="headerlink" title="1.配置Node.js和git"></a>1.配置<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a>和git</h3><h3 id="2-Github新建项目-账户名-github-io"><a href="#2-Github新建项目-账户名-github-io" class="headerlink" title="2.Github新建项目:账户名.github.io"></a>2.Github新建项目:账户名.github.io</h3><h3 id="3-Hexo与Github-page联系起来"><a href="#3-Hexo与Github-page联系起来" class="headerlink" title="3.Hexo与Github page联系起来"></a>3.Hexo与Github page联系起来</h3><p><strong>生成SSH Key</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxxxxx\blog&gt;</span><br><span class="line">$ git config --global user.name “github的账户名”</span><br><span class="line">$ git config --global user.email “github的邮箱名”</span><br></pre></td></tr></table></figure><p>执行后在blog文件夹会新建一个文件夹/.ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “github的邮箱名”</span><br></pre></td></tr></table></figure><p>连续三个回车，生成密钥，最后在/.ssh下生成了两个文件：id_rsa和id_rsa.pub</p><p><strong>添加SSH Key</strong></p><p>登录github，点击头像下的setting，添加ssh</p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去，其中windows默认读取私钥位置<code>/.ssh/id_rsa</code></p><p><strong>验证</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g#下载Hexo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init#初始化文件夹</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm install#安装所需组件</span><br><span class="line">$ npm install hexo-server --save</span><br><span class="line">$ npm install hexo-admin --save</span><br><span class="line">$ npm install hexo-generator-archive --save</span><br><span class="line">$ npm install hexo-generator-feed --save</span><br><span class="line">$ npm install hexo-generator-search --save</span><br><span class="line">$ npm install hexo-generator-tag --save</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g#hexo generate，生成静态文件</span><br><span class="line">$ hexo s#hexo server,在本地服务器运行</span><br></pre></td></tr></table></figure><p>##5.部署到Github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 清除、生成、启动</span><br><span class="line">$ hexo clean &amp;&amp; hexo g -s</span><br><span class="line"># 清除、生成、部署</span><br><span class="line">$ hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure><h2 id="6-更换主题"><a href="#6-更换主题" class="headerlink" title="6.更换主题"></a>6.更换主题</h2><p><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">主题</a></p><p><strong>复制主题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p><strong>启用主题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next#_config.yml</span><br></pre></td></tr></table></figure><h2 id="7-插入公式"><a href="#7-插入公式" class="headerlink" title="7.插入公式"></a>7.插入公式</h2><p><a href="https://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_blank" rel="noopener">Latex</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h2&gt;&lt;p&gt;可参考线上编辑器&lt;a href=&quot;https://www.zybuluo.com/mdedi
      
    
    </summary>
    
    
  </entry>
  
</feed>
